---
permalink: service-worker.js
---
const VERSION = '{{ nanoid }}';

const CACHE_KEYS = {
  PRE_CACHE: `precache-${VERSION}`,
  RUNTIME: `runtime-${VERSION}`,
};

// Assets to cache
const PRE_CACHE_URLS = [
  '/',
  '/404.html',
  '/index.html',
  '/about/index.html',
  '/contact/index.html',
  '/favicon.ico',
  '/images/social-share.png',
  '/images/icons/favicon.svg',
  '/images/icons/icon-72x72.png',
  '/images/icons/icon-96x96.png',
  '/images/icons/icon-128x128.png',
  '/images/icons/icon-144x144.png',
  '/images/icons/icon-152x152.png',
  '/images/icons/icon-192x192.png',
  '/images/icons/icon-384x384.png',
  '/images/icons/icon-512x512.png',
  '/images/icons/maskable_icon.png',
  '/styles/index.css',
];

// Assets to exclude from caching
const EXCLUDED_URLS = [];

// Array of ignored hosts
const IGNORED_HOSTS = ['localhost'];

// Cache static assets
self.addEventListener('install', function (event) {
  event.waitUntil(
    caches.open(CACHE_KEYS.PRE_CACHE).then(function (cache) {
      return cache.addAll(PRE_CACHE_URLS);
    }),
  );
});

// Clean-up old caches
self.addEventListener('activate', function (event) {
  event.waitUntil(
    caches
      .keys()
      .then(function (cacheNames) {
        return cacheNames.filter(function (item) {
          return !Object.values(CACHE_KEYS).includes(item);
        });
      })
      .then(function (itemsToDelete) {
        return Promise.all(
          itemsToDelete.map(function (item) {
            return caches.delete(item);
          }),
        );
      })
      .then(function () {
        return self.clients.claim();
      }),
  );
});

// Update caches
self.addEventListener('fetch', function (event) {
  const { hostname } = new URL(event.request.url);

  // Check for ignored hosts
  if (IGNORED_HOSTS.indexOf(hostname) >= 0) {
    return;
  }

  const getPageUrl = function (url) {
    return event.request.url.indexOf(url) > -1;
  };

  // Check for excluded URLs
  if (EXCLUDED_URLS.some(getPageUrl)) {
    return;
  }

  event.respondWith(
    caches.match(event.request).then(function (cachedResponse) {
      // If a cached response was found return it
      if (cachedResponse) {
        return cachedResponse;
      }

      // Load request from the network if no cached response was found
      return caches.open(CACHE_KEYS.RUNTIME).then(function (cache) {
        return fetch(event.request)
          .then(function (response) {
            // Add the new response to the cache and return it
            return cache.put(event.request, response.clone()).then(function () {
              return response;
            });
          })
          .catch(function () {
            return;
          });
      });
    }),
  );
});
